<?php 

class parse {

    function StartParse() { // Функция для запуска парсинга.
        $this->Parsing(0); // Запускаем парсинг с указанием начальной ссылки в массиве.
    }


    function Parsing($i) { // Функция для парсинга, рекурсивная функция.
        global $TotalAdress; // При каждом запуске обновляет данные массива
        global $TotalForSearch; // При каждом запуске обновляет данные массива

        $url = $TotalForSearch[$i]; // Получаем ссылку для парсинга из списка (массива).
        if ( substr($url, -1) == "/") { //Если в конце ссылки есть слэш
            $url = substr($url,0,-1); // Убирает слэш в конце ссылки
        } else if ( substr($url, -2) == "/ ") { // Убирает слэш в конце с пробелом
            $url = substr($url,0,-2);
        }

        $header = $this->get_http_response_code($url); // Проверяем на доступность страницы по ссылки.
        
        if($header == "403" || $header == "404"){ // Если страница не доступна.
            $content = false; // Пропускаем ссылку.
        }else{
            $content = file_get_contents($url); // Если ссылка доступна, скачиваем с неё содержимое.
        }
        
        if ($content != false) // Если содержимоем не пустое (если получилось скачать данные со страницы)
        {
            /* Здесь указываем методы для парсинга */

            $this->ParsingLinks($url, $content); // Парсим ссылки
            $this->ParsingImages($url, $content); // Парсим Изображения


            /* Если нужно расширить функционал программы, то сюда можно добавить новые функции,
            которые будут парсить другие данные (типы данных) с новым алгоритмом. */
            
        }

        echo $url . "\n"; // Сообщение про обработанную ссылку

        $i++; // Увеличиваем номер ссылки в массиве
        if (count($TotalForSearch) > $i) { // Если в массиве еще есть ссылки для парсинга
            $this->Parsing($i); // рекурсия, вызываем эту же функцию, со следующей ссылкой в миссиве.
        }
    }

    function ParsingLinks($url, $content) { //парсим ссылки на другие страницы

        $hrefs = explode('<a',$content);	//делим нашу строку контента на элементы массива, разделенные "<a"
        
        $hrefText = array(); // Инициализируем массив для дальнейшего использования.
		foreach($hrefs as $hrefsItem){	//Разделение строки, пока не останется только ссылка.
            $arHref = explode('href="',$hrefsItem);	//следующее деление строки на "href=""
            
            if (count($arHref) > 1) { //во избежания ошибок, пропускаем ход, если массив пустой.
                $arHref = explode('"',$arHref[1]);	//Деление строки, берем 2ой элемент массива
                $hrefText[] = $arHref[0]; // нужный нам отрезок строки в 1-ом элементе массива
            }
        }

        global $domain; // Получение домена
        $currectlyHref = array();// Инициализируем массив для дальнейшего использования.
        
        foreach($hrefText as $item) { //Корректируем ссылки в полноценный формат /index.php => www.website.com/index.php
            if ($item[0] == "/" || $item[0] == "#") { // Если ссылка не полная и нужно объеденить.  Объеденяем родительскую ссылку с обрезанной, получаем полноценную ссылку.
                if (strpos($url, '#') == false){ // Если метка уже стоит, чтобы не дублировать ссылки.
                    $currectlyHref[] = $url . $item; // Объеденение ссылки.
                }
            } else {
                $currectlyHref[] = $item; // Еслиобъеденение не нужно, просто вставляем в массив.
            }
        }

        $clearHrefs = array();// Инициализируем массив для дальнейшего использования.
		foreach($currectlyHref as $hrefItem){	
            //избавляемся от ссылок с пустым атрибутом href, от ссылок на сторонние источники 
            //и оставляем только внутренние ссылки и на собственный домен.
			if(($hrefItem != '') && ((strpos($hrefItem, $domain)) != false)){
				$clearHrefs[] = $hrefItem;
			}
        }
        
        if (count($clearHrefs) > 0) { //Если массив не пустой.
            $clearHrefs = array_unique($clearHrefs);	//избавляемся от одинаковых ссылок
            
            $merger = new merger; // Создание экземпляра объекта.
            $merger->MergeringLinks($url, $clearHrefs); //Слияние массивов. Добавляем новые ссылки в общий массив.
        }
    }

    function ParsingImages($url, $content) { //Парсим ссылки на картинки

        $hrefs = explode('<img',$content);	//делим нашу строку контента на элементы массива, разделенные "<img"
        $hrefText = array();// Инициализируем массив для дальнейшего использования.

		foreach($hrefs as $hrefsItem){	//Разделяем строки, пока не останется только ссылка.
            $arHref = explode('src="',$hrefsItem);	//следующее деление строки на "src=""

            if (count($arHref) > 1) { //во избежания ошибок, пропускаем ход, если массив пустой.
                $arHref = explode('"',$arHref[1]);	// берем 2ой элемент массива
                $hrefText[] = $arHref[0]; // нужный отрезок строки в 1ом элементе массива
            }
        }

        $currectlyHref = array();// Инициализируем массив для дальнейшего использования.
        global $domain; // Получаем искомый домен.
        foreach($hrefText as $item) { //Корректируем ссылки в полноценный формат /file.php => www.website.com/file.php
            $strHttp = stripos($item, "http"); // Если ссылка полноценная

            if ($item[0] == "/" || $item[0] == "#") { // Если ссылка не полная
                $currectlyHref[] = $url . $item; // Объеденяем родительскую ссылку с обрезанной, получаем полноценную ссылку.
            } 
            else if ($strHttp === false) { //Если ссылка не полноценная
                $currectlyHref[] = $url . "/" . $item; // делаем полноценную ссылку.
            }
            else {
                $currectlyHref[] = $item; // Если ссылка полноценная, просто добавляем в массив.
            }
        }

        $clearHrefs = array();// Инициализируем массив для дальнейшего использования.
		foreach($currectlyHref as $hrefItem){	
            //избавляемся от ссылок с пустым атрибутом src,
			if($hrefItem != ''){
				$clearHrefs[] = $hrefItem; // Если не пустая ссылка, добавляем в массив.
			}
        }
        
		$clearHrefs = array_unique($clearHrefs);	//избавляемся от одинаковых ссылок
        
        $merger = new merger; // Новый экземпляр объекта.
        $merger->MergeringImages($url, $clearHrefs); //Слияние массивов. Добавляем новые ссылки в общий массив.
    }

    function get_http_response_code($url) { // Получаем код заголовка соеденения.
        $headers = get_headers($url); // Считываем заголовки
        return substr($headers[0], 9, 3); // Возвращаем код ошибок.
    }


}



?>